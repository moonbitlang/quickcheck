// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/quickcheck"

import {
  "moonbitlang/core/bigint",
  "moonbitlang/core/buffer",
  "moonbitlang/core/list",
  "moonbitlang/core/quickcheck/splitmix",
  "moonbitlang/quickcheck/feat",
  "moonbitlang/quickcheck/rose",
}

// Values
pub fn alphabet() -> Gen[Char]

pub fn[A : Eq] associative((A, A) -> A) -> ((A, A, A)) -> Bool

pub fn[P : Testable] callback(P, Callback) -> Property

pub fn char_range(Char, Char) -> Gen[Char]

pub fn[P : Testable] classify(P, Bool, String) -> Property

pub fn[P : Testable, T : Show] collect(P, T) -> Property

pub fn[A, B : Eq] commutative((A, A) -> B) -> ((A, A)) -> Bool

pub fn[P : Testable] counterexample(P, String) -> Property

pub fn[A : Eq] distributive_left((A, A) -> A, (A, A) -> A) -> ((A, A, A)) -> Bool

pub fn[A : Eq] distributive_right((A, A) -> A, (A, A) -> A) -> ((A, A, A)) -> Bool

pub fn[A, B : Eq] ext_equal((A) -> B, (A) -> B) -> (A) -> Bool

pub fn failed() -> SingleResult

pub fn[P : Testable] filter(P, Bool) -> Property

pub fn[T] flatten_array(Array[Gen[T]]) -> Gen[Array[T]]

pub fn[T] flatten_list(@list.List[Gen[T]]) -> Gen[@list.List[T]]

pub fn[T] flatten_option(Gen[T]?) -> Gen[T?]

pub fn[T, E] flatten_result(Result[Gen[T], E]) -> Gen[Result[T, E]]

pub fn[T : Testable, A : Show] forall(Gen[A], (A) -> T) -> Property

pub fn[T : Testable, A : Show] forall_shrink(Gen[A], (A) -> Iter[A], (A) -> T) -> Property

pub fn[T] frequency(Array[(Int, Gen[T])]) -> Gen[T]

pub fn[T] frequency_list(@list.List[(Int, T)]) -> Gen[T]

pub fn[A : Eq] idempotent((A) -> A) -> (A) -> Bool

pub fn[P : Testable] if_fail(P, () -> Unit) -> Property

pub fn int_bound(Int) -> Gen[Int]

pub fn int_range(Int, Int) -> Gen[Int]

pub fn integer_bound(@bigint.BigInt) -> Gen[@bigint.BigInt]

pub fn[A : Eq, B] inverse((A) -> B, (B) -> A) -> (A) -> Bool

pub fn[A : Eq] involutory((A) -> A) -> (A) -> Bool

pub fn[P : Testable] label(P, String) -> Property

pub fn[A, B, C] liftA2((A, B) -> C, Gen[A], Gen[B]) -> Gen[C]

pub fn[A, B, C, D] liftA3((A, B, C) -> D, Gen[A], Gen[B], Gen[C]) -> Gen[D]

pub fn[A, B, C, D, E] liftA4((A, B, C, D) -> E, Gen[A], Gen[B], Gen[C], Gen[D]) -> Gen[E]

pub fn[A, B, C, D, E, F] liftA5((A, B, C, D, E) -> F, Gen[A], Gen[B], Gen[C], Gen[D], Gen[E]) -> Gen[F]

pub fn[A, B, C, D, E, F, G] liftA6((A, B, C, D, E, F) -> G, Gen[A], Gen[B], Gen[C], Gen[D], Gen[E], Gen[F]) -> Gen[G]

pub fn[T] list_with_size(Int, Gen[T]) -> Gen[@list.List[T]]

pub fn local_min_found(State, SingleResult) -> (Int, Int, Int, SingleResult)

pub fn[P : Testable] map_size(P, (Int) -> Int) -> Property

pub fn[P : Testable] map_total_result(P, (SingleResult) -> SingleResult) -> Property

pub fn[A : Compare, B : Compare] mono_decrease((A) -> B) -> ((A, A)) -> Bool

pub fn[A : Compare, B : Compare] mono_increase((A) -> B) -> ((A, A)) -> Bool

pub fn nat() -> Gen[Int]

pub fn neg_int() -> Gen[Int]

pub fn numeral() -> Gen[Char]

pub fn[T] one_of(Array[Gen[T]]) -> Gen[T]

pub fn[T] one_of_array(Array[T]) -> Gen[T]

pub fn[T] one_of_list(@list.List[T]) -> Gen[T]

pub fn[T] pure(T) -> Gen[T]

pub fn[T] pure_eq(T) -> Equivalence[T]

pub fn[T, U, V, W] quad(Gen[T], Gen[U], Gen[V], Gen[W]) -> Gen[(T, U, V, W)]

pub fn[P : Testable] quick_check(P, max_shrink? : Int, max_success? : Int, max_size? : Int, discard_ratio? : Int, expect? : Expected, abort? : Bool) -> Unit raise Failure

pub fn[A : @moonbitlang/core/quickcheck.Arbitrary + Shrink + Show, B : Testable] quick_check_fn((A) -> B, max_shrinks? : Int, max_success? : Int, max_size? : Int, discard_ratio? : Int, expect? : Expected, abort? : Bool) -> Unit raise Failure

pub fn[P : Testable] quick_check_silence(P, max_shrink? : Int, max_success? : Int, max_size? : Int, discard_ratio? : Int, expect? : Expected, abort? : Bool) -> String

pub fn[P : Testable] quick_check_with_result(Config, P) -> TestSuccess raise TestError

pub fn rejected() -> SingleResult

pub fn[P : Testable] run_prop(P) -> Gen[@rose.Rose[SingleResult]]

pub fn[P : Testable, T] shrinking((T) -> Iter[T], T, (T) -> P) -> Property

pub fn[T] sized((Int) -> Gen[T]) -> Gen[T]

pub fn small_int() -> Gen[Int]

pub fn[T : Compare] sorted_list(Int, Gen[T]) -> Gen[@list.List[T]]

pub fn succeed() -> SingleResult

pub fn[T, U, V] triple(Gen[T], Gen[U], Gen[V]) -> Gen[(T, U, V)]

pub fn[T, U] tuple(Gen[T], Gen[U]) -> Gen[(T, U)]

// Errors
type TestError

// Types and methods
pub(all) struct Arrow[A, B]((A) -> B)
#deprecated
pub fn[A, B] Arrow::inner(Self[A, B]) -> (A) -> B
pub impl[P : Testable, A : @moonbitlang/core/quickcheck.Arbitrary + Shrink + Show] Testable for Arrow[A, P]

type Axiom[T]
pub fn[T] Axiom::new((T) -> Equivalence[T]) -> Self[T]
pub fn[T] Axiom::run(Self[T], T) -> Equivalence[T]
pub fn[T, U] Axiom::to_property(Self[T], (T) -> U, (U, U) -> Bool) -> (T) -> Bool
pub fn[T, U : Eq] Axiom::to_property_eq(Self[T], (T) -> U) -> (T) -> Bool
pub fn[T, M, N] Axiom::to_property_parametric(Self[T], (T, M) -> N, (N, N) -> Bool) -> ((T, M)) -> Bool
pub fn[T, M, N : Eq] Axiom::to_property_parametric_eq(Self[T], (T, M) -> N) -> ((T, M)) -> Bool

type Callback

type Config

type Discard
pub impl Default for Discard
pub impl Testable for Discard

pub(all) struct Equivalence[T] {
  lhs : T
  rhs : T
}
pub fn[T, U] Equivalence::ap(Self[(T) -> U], Self[T]) -> Self[U]
pub fn[T, U] Equivalence::bind(Self[T], (T) -> Self[U]) -> Self[U]
pub fn[T] Equivalence::equal_by(Self[T], (T, T) -> Bool) -> Bool
pub fn[T, U] Equivalence::fmap(Self[T], (T) -> U) -> Self[U]
pub fn[T : Eq] Equivalence::is_equal(Self[T]) -> Bool
pub fn[T] Equivalence::new(T, T) -> Self[T]
pub impl[T : Show] Show for Equivalence[T]

pub(all) enum Expected {
  Fail
  Success
  GaveUp
}

type Gen[T]
pub fn[T, U] Gen::ap(Self[(T) -> U], Self[T]) -> Self[U]
pub fn[T] Gen::array_with_size(Self[T], Int) -> Self[Array[T]]
pub fn[T, U] Gen::bind(Self[T], (T) -> Self[U]) -> Self[U]
pub fn[T : @feat.Enumerable] Gen::feat_random(Int) -> Self[T]
pub fn[T, U] Gen::fmap(Self[T], (T) -> U) -> Self[U]
pub fn[T] Gen::join(Self[Self[T]]) -> Self[T]
pub fn[T] Gen::new((Int, @splitmix.RandomState) -> T) -> Self[T]
pub fn[T] Gen::resize(Self[T], Int) -> Self[T]
pub fn[T] Gen::run(Self[T], Int, @splitmix.RandomState) -> T
pub fn[T] Gen::sample(Self[T], size? : Int, seed? : UInt64) -> T
pub fn[T] Gen::samples(Self[T], size? : Int, seed? : UInt64) -> Array[T]
pub fn[T] Gen::scale(Self[T], (Int) -> Int) -> Self[T]
pub fn[T : @moonbitlang/core/quickcheck.Arbitrary] Gen::spawn() -> Self[T]
pub fn[T] Gen::such_that(Self[T], (T) -> Bool) -> Self[T]
pub fn[T] Gen::such_that_maybe(Self[T], (T) -> Bool) -> Self[T?]
pub impl[P : Testable] Testable for Gen[P]

pub(all) enum Outcome[T] {
  Success
  GaveUp
  Fail(T)
}
pub impl[T] Show for Outcome[T]

type Printer
pub fn Printer::format(Self, String) -> String
pub fn Printer::from_buffer(@buffer.Buffer) -> Self
pub fn Printer::ident(Self, size? : Int) -> Unit
pub fn Printer::unident(Self) -> Unit
pub fn Printer::write_string(Self, String) -> Unit
pub impl Default for Printer

type Property
pub impl Testable for Property

pub(all) struct Replay {
  rand_state : @splitmix.RandomState
  size : Int
}
pub fn Replay::new(@splitmix.RandomState, Int) -> Self

type SingleResult
pub impl Testable for SingleResult

type State
pub fn State::complete_test(Self, Property) -> TestSuccess raise TestError
pub fn State::find_failure(Self, SingleResult, Iter[@rose.Rose[SingleResult]]) -> TestSuccess raise TestError
pub fn State::give_up(Self, Property) -> TestSuccess raise TestError
pub fn State::local_min(Self, SingleResult, Iter[@rose.Rose[SingleResult]]) -> (Int, Int, Int, SingleResult)
pub fn State::run_single_test(Self, Property) -> Result[TestSuccess, Self] raise TestError
pub fn State::run_test(Self, Property) -> TestSuccess raise TestError

type TestSuccess

// Type aliases
pub using @splitmix {type RandomState}

// Traits
pub(open) trait Shrink {
  shrink(Self) -> Iter[Self] = _
}
pub impl Shrink for Unit
pub impl Shrink for Bool
pub impl Shrink for Char
pub impl Shrink for Int
pub impl Shrink for Int64
pub impl Shrink for UInt
pub impl Shrink for UInt64
pub impl Shrink for Float
pub impl Shrink for Double
pub impl Shrink for String
pub impl[T : Shrink] Shrink for T?
pub impl[T : Shrink, E : Shrink] Shrink for Result[T, E]
pub impl Shrink for Bytes
pub impl[X : Shrink] Shrink for Array[X]
pub impl[X : Shrink] Shrink for Iter[X]
pub impl[T : Shrink] Shrink for @list.List[T]
pub impl[A : Shrink, B : Shrink] Shrink for (A, B)
pub impl[A : Shrink, B : Shrink, C : Shrink] Shrink for (A, B, C)
pub impl[A : Shrink, B : Shrink, C : Shrink, D : Shrink] Shrink for (A, B, C, D)
pub impl[A : Shrink, B : Shrink, C : Shrink, D : Shrink, E : Shrink] Shrink for (A, B, C, D, E)
pub impl[A : Shrink, B : Shrink, C : Shrink, D : Shrink, E : Shrink, F : Shrink] Shrink for (A, B, C, D, E, F)

pub(open) trait Testable {
  property(Self) -> Property
}
pub impl Testable for Unit
pub impl Testable for Bool
pub impl[P : Testable] Testable for P?
pub impl Testable for @rose.Rose[SingleResult]

