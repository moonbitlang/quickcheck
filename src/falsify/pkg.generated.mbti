// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/quickcheck/falsify"

import {
  "moonbitlang/core/list",
  "moonbitlang/core/quickcheck/splitmix",
}

// Values
pub fn[T : Show, E] collect(String, @list.List[T]) -> Property[Unit, E]

pub fn combine_shrunk(Sample, SampleTree, SampleTree, Iter[SampleTree], Iter[SampleTree]) -> Iter[SampleTree]

pub fn constant(UInt) -> SampleTree

pub fn[T, E] discard() -> Property[T, E]

pub fn[T, E] falsify(Config, Property[T, E]) -> (@splitmix.RandomState, @list.List[Success[T]], Int, Failure[E]?)

pub fn from_rng(@splitmix.RandomState) -> SampleTree

pub fn from_seed(UInt64) -> SampleTree

pub fn[T, E] gen((T) -> String?, Gen[T]) -> Property[T, E]

pub fn info(String) -> Property[Unit, String]

pub fn[T] init_state(Config) -> DriverState[T]

pub fn init_test_run() -> TestRun

pub fn[E] label(String, @list.List[String]) -> Property[Unit, E]

pub fn[T, E] mk_property((TestRun) -> Gen[(TestResult[T, E], TestRun)]) -> Property[T, E]

pub fn[T] new((SampleTree) -> (T, Iter[SampleTree])) -> Gen[T]

pub fn prim() -> Gen[UInt]

pub fn prim_with((Sample) -> Iter[UInt]) -> Gen[Sample]

pub fn[T] pure(T) -> Gen[T]

pub fn[T, E] run_property(Property[T, E]) -> Gen[(TestResult[T, E], TestRun)]

pub fn[A, B, C] second((B) -> C, (A, B)) -> (A, C)

pub fn[T] shrink_to_list(T, Iter[T]) -> Gen[T]

pub fn[T] test_gen((T) -> Bool, Gen[T]) -> Property[T, String]

// Errors

// Types and methods
type Config
pub impl Default for Config
pub impl Show for Config

type DriverState[T]

type Either[L, R]

type Failure[E]
pub impl[E : Show] Show for Failure[E]

type Gen[T]
pub fn[T, U] Gen::ap(Self[(T) -> U], Self[T]) -> Self[U]
pub fn[A, B] Gen::apS(Self[(A) -> B], Self[A]) -> Self[B]
pub fn[T, U] Gen::bind(Self[T], (T) -> Self[U]) -> Self[U]
pub fn[A, B, C] Gen::branch(Self[Either[A, B]], Self[(A) -> C], Self[(B) -> C]) -> Self[C]
pub fn[T, U] Gen::fmap(Self[T], (T) -> U) -> Self[U]
pub fn[T] Gen::ifS(Self[Bool], Self[T], Self[T]) -> Self[T]
pub fn[T] Gen::run_gen(Self[T], SampleTree) -> (T, Iter[SampleTree])
pub fn[T] Gen::sample(Self[T]) -> T
pub fn[T, U] Gen::select(Self[(T) -> U], Self[Either[T, U]]) -> Self[U]
pub fn[A, P, N] Gen::shrink_from(Self[A], (A) -> IsValidShrink[P, N], (P, Iter[SampleTree])) -> ShrinkExplain[P, N]

type IsValidShrink[P, N]

type Property[T, E]
pub fn[T, E] Property::run(Self[T, E], TestRun) -> Gen[(TestResult[T, E], TestRun)]

type Sample
pub fn Sample::sample_value(Self) -> UInt

type SampleTree
pub fn SampleTree::map(Self, (UInt) -> UInt) -> Self
pub fn SampleTree::mod(Self, UInt) -> Self
pub fn SampleTree::view(Self) -> (Sample, Self, Self)

type ShrinkExplain[P, N]
pub fn[P, N] ShrinkExplain::limit_steps(Self[P, N], Int?) -> Self[P, N]
pub fn[P, N] ShrinkExplain::shrink_history(Self[P, N]) -> Array[P]
pub fn[P, N] ShrinkExplain::shrink_outcome(Self[P, N]) -> (P, Iter[N]?)
pub impl[P : Show, N : Show] Show for ShrinkExplain[P, N]

type Success[T]
pub impl[T : Show] Show for Success[T]

type TestResult[T, E]

type TestRun
pub impl Show for TestRun

// Type aliases
pub using @list {type List}

pub using @splitmix {type RandomState}

// Traits

